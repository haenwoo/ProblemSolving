##### 출처 https://programmers.co.kr/learn/courses/30/lessons/43236
##### 프로그래머스 징검다리 C++

# 문제 설명<br>
#### 출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다.
#### 예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.
<br>
| 제거한 바위의 위치	 | 각 바위 사이의 거리	 | 거리의 최솟값 |
|:---|:----|:---:
| [21, 17] | [2, 9, 3, 11] | 2 |
| [2, 21] | [11, 3, 3, 8] | 3 |
| [2, 11] | [14, 3, 4, 4] | 3 |
| [11, 21] | [2, 12, 3, 8] | 2 |
| [2, 14] | [11, 6, 4, 4] | 4 | 
<br>

#### 위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.
#### 출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때,
#### 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.
<br>

## 제한 사항
- 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.
- 바위는 1개 이상 50,000개 이하가 있습니다.
- n 은 1 이상 바위의 개수 이하입니다.
<br><br>

## 입출력 예  
| distance | rocks | n | return |
|:---|:------|:---|:---|
| 25 | [2, 14, 11, 21, 17] | 2 | 4 |

## 문제 풀이 <br>
이분탐색의 기준이 바위 사이의 거리가 된다.  
거리 D 가 바위 사이 간격의 최소값이 되기 위해 제거해야 하는 바위의 수를 계산했을 때,  
이 값이 n 보다 클 경우 n 개의 바위를 제거한 것으로 D 가 최소가 될 수 없으며, 작거나 같을 경우 D 가 최소가 될 수 있다.  
최소가 될 수 없는 경우는 D 가 높게 잡힌 것으로 이때는 이분탐색에서 high 값을 내리고, 반대의 경우는 올린다.  
문제에서 요구하는 답은 n 개의 바위를 없애서 나온 최소값 중에 최대값이기 때문에, mid 값이 최대가 될때까지 이분탐색을 반복하며  
최대가 되는 D 값이 실제로 존재하는 바위 사이의 간격이 된다.  
최대가 아닌 D 값은 최소가 될 수 있는 것이지 바위 사이의 간격으로 존재하는 것을 보장하지 않는다.  
복잡도는 이분탐색 하는데 log(Distance), 없애야 하는 바위를 세는 과정에서 Rocks.size() 비용이 들기 때문에
Rlog(Di) 가 된다. 이때 R = 바위 개수, Di 는 출발점에서 도착지점의 거리  