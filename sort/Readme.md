# 정렬

## Quick sort
#### 어떤 값을 기준으로 큰것과 작은것들로 눠서 정렬을 한다.  
#### 알고리즘 방식
- 어떤 값 -> pivot 값을 기준으로 왼쪽에서는 큰값을 찾고, 오른쪽에서는 작은값을 찾는다.
- 찾은 값들을 스와핑 한다. 스와핑 한 후 계속 진행
- 큰값을 찾는 인덱스가 작은값을 찾는 인덱스보다 커지면 작은 값을 가리키는 인덱스와 pivot을 바꾼다.
- 이때 pivot을 기준으로 왼쪽에는 작은 값, 오른쪽에는 큰 값들만 위치하게 된다.
- pivot을 기준으로 왼쪽과 오른쪽 값들에 대해 quick sort 각각 수행

#### simulation
1. pivot은 첫번째 값으로 시작, 이때는 pivot = 4
- (4) 3 1 7 5 8 9 0 2 6  
2. 왼쪽부터 4보다 큰 값을 찾고, 오른쪽부터 작은 값을 찾는다. 
- (4) 3 1 [7] 5 8 9 0 {2} 6  
3. 찾은 값을 스와핑
- (4) 3 1 [2] 5 8 9 0 {7} 6  
4. 계속해서 진행,  
- (4) 3 1 2 [5] 8 9 {0} 7 6  
- (4) 3 1 2 [0] 8 9 {5} 7 6 <- 스와핑  
- (4) 3 1 2 {0} [8] 9 5 7 6 <- 이때 인덱스가 엇갈림  
5. 인덱스가 엇갈렸기 때문에 작은값과 pivot을 스와핑
- {0} 3 1 2 (4) [8] 9 5 7 6  
6. pivot 값을 기준으로 나뉜 것으로 다시 quick sort를 각각 수행  
...

#### 복잡도
- 평균 복잡도 : NlogN  
- 최악의 경우 복잡도 : N^2  

#### 평균 복잡도가 NlogN 인 이유??  
&nbsp;계속 반정도로 값들이 나눠지면서 진행을 한다면 Quick Sort 알고리즘 수행이 logN 번 하게 된다.  
&nbsp;각각의 수행에서 나눠진 리스트로 Quick Sort를 수행하기 되는데 이때 총 탐색 횟수는 N이다.  
&nbsp;따라서 NlogN 이 된다.  

#### 최악의 복잡도가 N^2 인 이유?
&nbsp; 아래와 같이 이미 정렬된 것에 대해서는 Quick Sort 과정에서 Pivot 값으로 나누더라도  
&nbsp; 왼쪽에 있는 값을 하나씩 빼면서 정렬을 계속 수행하는 것이 된다. 이렇게 N번을 수행해야 한다.  
- 0 1 2 3 4 5 6 7 8 9  

&nbsp; 그렇기 때문에 수행은 1+2+3+...+N = N(N+1)/2 -> N^2 이 된다.  



## Merge Sort
#### 리스트를 반으로 나누어서 합치면서 정렬을 한다
#### 알고리즘 방식
1. 아래와 같은 리스트가 있을 때 우선 반으로 나눈다.  
- 4 3 1 7 5 8 2 6 
2. 반으로 나누면 아래와 같다.
- 4 3 1 7  
- 5 8 2 6  
3. 이렇게 하나씩 남을 때까지 나눈다.
- 4 | 3 | 1 | 7 | 5 | 8 | 2 | 6 |  
4. 이때 나눠진것을 단계별로 합치면서 크기 순으로 합친다. 
- 4 | 3 | 1 | 7 | 5 | 8 | 2 | 6 | 
<br> 
- | 3  4 |, | 1  7 |,  |5  8 |,  | 2  6 |  
<br> 
- | 1  3  4  7 |,  |2  5  6   8 |  
<br> 
- |1  2  3  4  5  6  7  8|  

#### 복잡도
- NlogN  
&nbsp; N -> 나눠진 각 리스트에서 하나씩 가져오는 횟수 : N 개가 4개로 나눠진 상태라면 (1/4 + 1/4 + 1/4 + 1/4)N  
&nbsp; logN -> 합치는 것을 logN 번 하면 된다. : 8 개의 리스트를 2, 4, 8 개씩 나눠서 합치면 됨  


## Heap Sort
#### 최대 힙, 최소 힙을 이용하여 정렬하는 방식
#### 힙 구조
- 최대 힙 : 루트 노드가 항상 자식 노드보다 값이 큰 완전 이진트리
- 최소 힙 : 루트 노드가 항상 자식 노드보다 값이 작은 완전 이진트리

#### 알고리즘 방식
1. 최대 힙을 만든다.
2. 이때 루트노드에는 가장 큰 값이 위치하게 된다. 루트 노드의 값을 가장 끝으로 둔다.
3. 가장 끝으로 옮긴 노드는 제외하고 최대힙을 만든다.
4. 이를 반복

#### 복잡도
- NlogN <- 처음 힙을 만드는데 드는 복잡도  
N 개의 값들에 대해서 각각 힙 알고리즘 수행(루트노드보다 자식 노드가 크면 스와핑하면서 자식 노드로 이동 이 복잡도는 logN)  
- N <- 정렬 반복 횟수
- logN <- 정렬 과정 중 다시 최대 힙을 만드는 복잡도,  
logN 이 되는 이유는 이미 만들어진 상태에서 root 노드에 대해서만 힙을 만드는 알고리즘 수행