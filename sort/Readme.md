# 정렬

## Quick sort
#### 어떤 값을 기준으로 큰것과 작은것들로 눠서 정렬을 한다.  
#### 알고리즘 방식
- 어떤 값 -> pivot 값을 기준으로 왼쪽에서는 큰값을 찾고, 오른쪽에서는 작은값을 찾는다.
- 찾은 값들을 스와핑 한다. 스와핑 한 후 계속 진행
- 큰값을 찾는 인덱스가 작은값을 찾는 인덱스보다 커지면 작은 값을 가리키는 인덱스와 pivot을 바꾼다.
- 이때 pivot을 기준으로 왼쪽에는 작은 값, 오른쪽에는 큰 값들만 위치하게 된다.
- pivot을 기준으로 왼쪽과 오른쪽 값들에 대해 quick sort 각각 수행

#### simulation
1. pivot은 첫번째 값으로 시작, 이때는 pivot = 4
- (4) 3 1 7 5 8 9 0 2 6  
2. 왼쪽부터 4보다 큰 값을 찾고, 오른쪽부터 작은 값을 찾는다. 
- (4) 3 1 [7] 5 8 9 0 {2} 6  
3. 찾은 값을 스와핑
- (4) 3 1 [2] 5 8 9 0 {7} 6  
4. 계속해서 진행,  
- (4) 3 1 2 [5] 8 9 {0} 7 6  
- (4) 3 1 2 [0] 8 9 {5} 7 6 <- 스와핑  
- (4) 3 1 2 {0} [8] 9 5 7 6 <- 이때 인덱스가 엇갈림  
5. 인덱스가 엇갈렸기 때문에 작은값과 pivot을 스와핑
- {0} 3 1 2 (4) [8] 9 5 7 6  
6. pivot 값을 기준으로 나뉜 것으로 다시 quick sort를 각각 수행  
...

#### 복잡도
- 평균 복잡도 : NlogN  
- 최악의 경우 복잡도 : N^2  

#### 평균 복잡도가 NlogN 인 이유??  
&nbsp;계속 반정도로 값들이 나눠지면서 진행을 한다면 Quick Sort 알고리즘 수행이 logN 번 하게 된다.  
&nbsp;각각의 수행에서 나눠진 리스트로 Quick Sort를 수행하기 되는데 이때 총 탐색 횟수는 N이다.  
&nbsp;따라서 NlogN 이 된다.  

#### 최악의 복잡도가 N^2 인 이유?
&nbsp; 아래와 같이 이미 정렬된 것에 대해서는 Quick Sort 과정에서 Pivot 값으로 나누더라도  
&nbsp; 왼쪽에 있는 값을 하나씩 빼면서 정렬을 계속 수행하는 것이 된다. 이렇게 N번을 수행해야 한다.  
- 0 1 2 3 4 5 6 7 8 9  

&nbsp; 그렇기 때문에 수행은 1+2+3+...+N = N(N+1)/2 -> N^2 이 된다.  


